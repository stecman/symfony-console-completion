<?php


namespace Stecman\Component\Symfony\Console\BashCompletion;


final class HookFactory
{
    /**
     * Hook scripts
     *
     * These are shell-specific scripts that pass required information from existing
     * completion systems in a common form the completion component of this module.
     *
     * The following placeholders are replaced with their value at runtime:
     *
     *     %%function_name%%      - name of the generated shell function run for completion
     *     %%program_name%%       - command name completion will be enabled for
     *     %%program_path%%       - path to program the completion is for/generated by
     *     %%completion_command%% - command to be run to compute completions
     *
     * NOTE: Comments are stripped out by HookFactory::stripComments as eval reads
     *       input as a single line, causing it to break if comments are included.
     *       While comments work using `... | source /dev/stdin`, existing installations
     *       are likely using eval as it's been part of the instructions for a while.
     *
     * @var array
     */
    protected static $hooks = array(
        // BASH Hook
        'bash' => <<<'END'
# BASH completion for %%program_path%%
function %%function_name%% {
    export COMP_LINE COMP_POINT COMP_WORDBREAKS;
    local RESULT STATUS;

    RESULT="$(%%completion_command%%)";
    STATUS=$?;

    local cur;
    _get_comp_words_by_ref -n : cur;

    # Check if shell provided path completion is requested
    # @see Completion\ShellPathCompletion
    if [ $STATUS -eq 200 ]; then
        _filedir;
        return 0;

    # Bail out if PHP didn't exit cleanly
    elif [ $STATUS -ne 0 ]; then
        echo -e "$RESULT";
        return $?;
    fi;

    COMPREPLY=(`compgen -W "$RESULT" -- $cur`);

    __ltrim_colon_completions "$cur";
};

if command -v _get_comp_words_by_ref >/dev/null 2>&1; then
    complete -F %%function_name%% %%program_name%%;
fi
END

        // ZSH Hook
        , 'zsh' => <<<'END'
# ZSH completion for %%program_path%%
function %%function_name%% {
    # Emulate BASH's command line contents variable
    local -x COMP_LINE="$words"

    # Emulate BASH's cursor position variable, setting it to the end of the current word.
    local -x COMP_POINT
    (( COMP_POINT = ${#${(j. .)words[1,CURRENT]}} ))

    local RESULT STATUS
    local -x COMPOSER_CWD=`pwd`
    RESULT=("${(@f)$( %%completion_command%% )}")
    STATUS=$?;

    # Check if shell provided path completion is requested
    # @see Completion\ShellPathCompletion
    if [ $STATUS -eq 200 ]; then
        _path_files;
        return 0;

    # Bail out if PHP didn't exit cleanly
    elif [ $STATUS -ne 0 ]; then
        echo -e "$RESULT";
        return $?;
    fi;

    compadd -- $RESULT
};

compdef %%function_name%% %%program_name%%;
END
    );

    public static function getShellTypes()
    {
        return array_keys(self::$hooks);
    }

    /**
     * Return a completion hook for the specified shell type
     *
     * @param string $type - a key from self::$hooks
     * @param string $programPath
     * @param string $programName
     * @return string
     */
    public function generateHook($type, $programPath, $programName = null)
    {
        if (!isset(self::$hooks[$type])) {
            throw new \RuntimeException(sprintf(
                "Cannot generate hook for unknown shell type '%s'. Available hooks are: %s",
                $type,
                implode(', ', self::getShellTypes())
            ));
        }

        // Use the program path if an alias/name is not given
        $programName = $programName ?: $programPath;

        return str_replace(array(
                '%%function_name%%',
                '%%program_name%%',
                '%%program_path%%',
                '%%completion_command%%',
            ), array(
                $this->generateFunctionName($programPath, $programName),
                $programName,
                $programPath,
                "$programPath _completion"
            ),
            $this->stripComments(self::$hooks[$type])
        );
    }

    /**
     * Generate a function name that is unlikely to conflict with other
     * generated function names in the same shell
     */
    protected function generateFunctionName($programPath, $programName)
    {
        return sprintf('_%s_%s_complete',
            basename($programName),
            substr(md5($programPath), 0, 16)
        );
    }

    /**
     * BASH's eval doesn't work with comments, so these have to be stripped out
     * @param string $script
     * @return string
     */
    protected function stripComments($script)
    {
        return preg_replace('/(^\s*\#.*$)/m', '', $script);
    }
}